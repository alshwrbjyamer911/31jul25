/*
 * SSD1309.c
 *
 *  Created on: Jul 13, 2025
 *      Author: rk
 */


#include"main.h"
#include"SSD1309.h"


const uint8_t init_sequence[] = {
		0xAE,       // Display OFF
		0xA4,       // ignores contents of display RAM
		0xA6,       // Normal display (not inverted)
		0xA8, 0x3F, // Multiplex ratio
		0xD3, 0x00, // Display offset
		0x40,       // Display start line
		0xA1,       // Segment remap
		0xC8,       // COM output scan direction
		0xDA, 0x12, // COM pins config
		0x81, 0x7F, // Contrast
		0xA4,       // Output follows RAM content
		0xD5, 0x80, // Clock divide
		0x8D, 0x14, // Charge pump
		0xAF        // Display ON
};

#if 0
unsigned char buffer[12][7] ={
		{0x00,0x00,0x7e,0xe1,0x91,0x8d,0x7e,0x00,0x00}, //0
		{0x00,0x00,0x82,0x83,0xff,0x80,0x80,0x00,0x00}, //1
		{0x00,0x00,0xc2,0xa1,0x91,0x89,0x86,0x00,0x00}, //2
		{0x00,0x00,0x91,0x91,0x91,0x91,0x6e,0x00,0x00}, //3
		{0x00,0x00,0x1f,0x10,0x10,0x10,0xff,0x00,0x00}, //4
		{0x00,0x00,0x8f,0x89,0x89,0x89,0x71,0x00,0x00}, //5
		{0x00,0x00,0xff,0x91,0x91,0x91,0xf3,0x00,0x00}, //6
		{0x00,0x00,0x01,0xe1,0x11,0x09,0x07,0x00,0x00}, //7
		{0x00,0x00,0xff,0x91,0x91,0x91,0xff,0x00,0x00}, //8
		{0x00,0x00,0x8f,0x89,0x89,0x89,0xff,0x00,0x00}, //9
		{0x00,0x00,0x00,0x66,0x66,0x66,0x00,0x00,0x00}, //:
		{0x00,0x00,0x40,0x20,0x10,0x08,0x04,0x00,0x00}  ///
};
#endif
/*---------------------------FONTS ----------------------*/
uint8_t charset[ ][9]={
		{0x00, 0x00, 0x7e, 0xe1, 0x91, 0x8d, 0x7e, 0x00, 0x00}, //0
		{0x00, 0x00, 0x82, 0x83, 0xff, 0x80, 0x80, 0x00, 0x00}, //1
		{0x00, 0x00, 0xc2, 0xa1, 0x91, 0x89, 0x86, 0x00, 0x00}, //2
		{0x00, 0x00, 0x91, 0x91, 0x91, 0x91, 0x6e, 0x00, 0x00}, //3
		{0x00, 0x00, 0x1f, 0x10, 0x10, 0x10, 0xff, 0x00, 0x00}, //4
		{0x00, 0x00, 0x8f, 0x89, 0x89, 0x89, 0x71, 0x00, 0x00}, //5
		{0x00, 0x00, 0xff, 0x91, 0x91, 0x91, 0xf3, 0x00, 0x00}, //6
		{0x00, 0x00, 0x01, 0xe1, 0x11, 0x09, 0x07, 0x00, 0x00}, //7
		{0x00, 0x00, 0xff, 0x91, 0x91, 0x91, 0xff, 0x00, 0x00}, //8
		{0x00, 0x00, 0x8f, 0x89, 0x89, 0x89, 0xff, 0x00, 0x00}, //9
		{0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00}, //:
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //dummy
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //dummy
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //dummy
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //dummy
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //dummy
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //dummy
		{0x00, 0xfe, 0x11, 0x11, 0x11, 0x11, 0x11, 0xfe, 0x00}, //A-17
		{0x00, 0xff, 0x91, 0x91, 0x91, 0x91, 0x91, 0x6e, 0x00}, //B-18
		{0x00, 0x7e, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x00}, //C-19
		{0x00, 0x81, 0xff, 0x81, 0x81, 0x81, 0x81, 0x7e, 0x00}, //D-20
		{0x00, 0xff, 0x91, 0x91, 0x91, 0x91, 0x91, 0x81, 0x00}, //E-21
		{0x00, 0xff, 0x11, 0x11, 0x11, 0x11, 0x11, 0x01, 0x00}, //F-22
		{0x00, 0x7e, 0x81, 0x81, 0x81, 0x91, 0x91, 0x70, 0x00}, //G-23
		{0x00, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0xff, 0x00}, //H-24
		{0x00, 0x81, 0x81, 0x81, 0xff, 0x81, 0x81, 0x81, 0x00}, //I-25
		{0x00, 0x60, 0x80, 0x81, 0x81, 0x7f, 0x01, 0x01, 0x00}, //J-26
		{0x00, 0x00, 0xff, 0x18, 0x24, 0x42, 0x81, 0x00, 0x00}, //K-27
		{0x00, 0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00}, //L-28
		{0x00, 0xff, 0x02, 0x04, 0x08, 0x04, 0x02, 0xff, 0x00}, //M-29
		{0x00, 0xff, 0x02, 0x04, 0x08, 0x10, 0x20, 0xff, 0x00}, //N-30
		{0x00, 0x7e, 0x81, 0x81, 0x81, 0x81, 0x81, 0x7e, 0x00}, //0-31
		{0x00, 0xff, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00}, //P-32
		{0x00, 0x7e, 0x81, 0x81, 0x91, 0xa1, 0x41, 0xbe, 0x00}, //Q-33
		{0x00, 0xff, 0x11, 0x11, 0x31, 0x51, 0x91, 0x0e, 0x00}, //R-34
		{0x00, 0x8e, 0x91, 0x91, 0x91, 0x91, 0x91, 0x61, 0X00}, //S-35
		{0x00, 0x01, 0x01, 0x01, 0xff, 0x01, 0x01, 0x01, 0X00}, //T-36
		{0x00, 0x7f, 0x80, 0x80, 0x80, 0x80, 0x80, 0x7f, 0X00}, //U-37
		{0x00, 0x1f, 0x20, 0x40, 0x80, 0x40, 0x20, 0x1f, 0X00}, //V-38
		{0x00, 0xff, 0x40, 0x20, 0x10, 0x20, 0x40, 0xff, 0X00}, //W-23
		{0x00, 0x81, 0x42, 0x24, 0x18, 0x24, 0x42, 0x81, 0X00}, //X-24
		{0x00, 0x01, 0x02, 0x04, 0xf8, 0x04, 0x02, 0x01, 0X00}, //Y-25
		{0x00, 0xc1, 0xa1, 0x91, 0x89, 0x85, 0x83, 0x81, 0X00}  //Z-26
};
#define SSD1309_WIDTH   128
#define SSD1309_HEIGHT   64

extern SPI_HandleTypeDef hspi1;

uint8_t SSD1309_Buffer[SSD1309_WIDTH * SSD1309_HEIGHT / 8];

void SSD1309_WriteCommand(uint8_t cmd) {
	HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_RESET);    // CS LOW
	HAL_GPIO_WritePin(DATA_CMD_PORT, DATA_CMD_PIN, GPIO_PIN_RESET);    // D/C pin LOW (Command)

	HAL_SPI_Transmit(&hspi1, &cmd, 1, HAL_MAX_DELAY);            // Send command byte

	HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_SET);      // CS HIGH
}



void SSD1309_WriteData(uint8_t * data, size_t length) {
	HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_RESET);    // CS LOW
	HAL_GPIO_WritePin(DATA_CMD_PORT, DATA_CMD_PIN, GPIO_PIN_SET);      // D/C HIGH (Data)

	HAL_SPI_Transmit(&hspi1, data, length, HAL_MAX_DELAY);       // Send display buffer

	HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_SET);      // CS HIGH
}



void SSD1309_Reset(void) {
	HAL_GPIO_WritePin(RES_PORT, RES_PIN, GPIO_PIN_RESET);
	HAL_Delay(10);
	HAL_GPIO_WritePin(RES_PORT, RES_PIN, GPIO_PIN_SET);
	HAL_Delay(10);
}

void InitDisplay()
{
	int i=0;

	for(i=0; i<20; i++)
	{
		SSD1309_WriteCommand(init_sequence[i]);
	}
}


void SSD1309_UpdateScreen(void) {


	for (uint8_t page = 0; page < 8; page++) {
		SSD1309_WriteCommand(0xB0 + page);        // Set page address
		SSD1309_WriteCommand(0x00);               // Set lower column address
		SSD1309_WriteCommand(0x10);               // Set higher column address
		SSD1309_WriteData(&SSD1309_Buffer[SSD1309_WIDTH * page], SSD1309_WIDTH);

	}
}


void SSD1309_Fill(uint8_t color) {
	for (uint16_t i = 0; i < sizeof(SSD1309_Buffer); i++) {
		SSD1309_Buffer[i] = color ? 0xFF : 0x00;
	}
}

void SSD1309_DrawPixel(uint8_t x, uint8_t y, uint8_t color) {
	if (x >= SSD1309_WIDTH || y >= SSD1309_HEIGHT) return;

	if (color)
		SSD1309_Buffer[x + (y / 8) * SSD1309_WIDTH] |= (1 << (y % 8));
	else
		SSD1309_Buffer[x + (y / 8) * SSD1309_WIDTH] &= ~(1 << (y % 8));
}


void SSD1309_DrawRectangle(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, uint8_t color) {
	if (x1 >= SSD1309_WIDTH)  x1 = SSD1309_WIDTH - 1;
	if (y1 >= SSD1309_HEIGHT) y1 = SSD1309_HEIGHT - 1;

	// Top and bottom horizontal lines
	for (uint8_t x = x0; x <= x1; x++) {
		SSD1309_DrawPixel(x, y0, color);
		SSD1309_DrawPixel(x, y1, color);
	}

	// Left and right vertical lines
	for (uint8_t y = y0; y <= y1; y++) {
		SSD1309_DrawPixel(x0, y, color);
		SSD1309_DrawPixel(x1, y, color);
	}
}

void tempwrite()
{
	uint8_t tempbuff=0xff;
	uint8_t i=0;

	for(i=0; i<10; i++)
	{
		SSD1309_WriteData(&tempbuff, 1);
	}

}

void ClearScreen()
{
	uint8_t page=0;
	uint8_t clearbuff[1024]={0};
	for(page=0; page<8; page++)
	{

		/*page addressing mode*/
		SSD1309_WriteCommand(0xB0 + page);
		SSD1309_WriteCommand(0x00 );
		SSD1309_WriteCommand(0x10);
		/*write char*/
		SSD1309_WriteData(&clearbuff, 128);
	}
}

void WriteText(uint8_t u8Colmn, uint8_t u8page,unsigned char * data)
{



	uint8_t i=0;

	uint8_t temp=0;


	/*page addressing mode*/
			SSD1309_WriteCommand(0xB0 + u8page);
			SSD1309_WriteCommand(0x00 | (u8Colmn & 0x0F));
			SSD1309_WriteCommand(0x10 | (u8Colmn >> 4));



	if((u8page < 8) && (u8Colmn< 128))
	{
		/*page addressing mode*/
		SSD1309_WriteCommand(0xB0 + u8page);
		SSD1309_WriteCommand(0x00 | (u8Colmn & 0x0F));
		SSD1309_WriteCommand(0x10 | (u8Colmn >> 4));
		/*write char*/

		for(i=0; data[i] !='\0'; i++)
		{
			if(( ((uint8_t)data[i]>=48u) &&((uint8_t)data[i]<=90u ))||((uint8_t)data[i] ==32u) ){
			if((u8Colmn >=128) || ((128-u8Colmn)<9))
			{
				u8page++;
				if(u8page <8)
				{
					u8Colmn=0;
					if(data[i] == 32u)
					{
						temp=15;
					}else{
					temp=data[i]-48;
					}
					SSD1309_WriteCommand(0xB0 + u8page);
					SSD1309_WriteCommand(0x00 | (u8Colmn & 0x0F));
					SSD1309_WriteCommand(0x10 | (u8Colmn >> 4));
					SSD1309_WriteData(&charset[temp][0], 9);

				}else
				{
					return;
				}

			}else
			{
				if(data[i] == 32u)
				{
					temp=15;
				}else{
					temp=data[i]-48;
				}
				SSD1309_WriteData(&charset[temp][0], 9);
				u8Colmn +=9;
			}

		}
		}



	}

}
